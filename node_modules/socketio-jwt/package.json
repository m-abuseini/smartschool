{
  "name": "socketio-jwt",
  "version": "4.3.4",
  "description": "authenticate socket.io connections using JWTs",
  "main": "lib/index.js",
  "keywords": [
    "socket",
    "socket.io",
    "jwt"
  ],
  "author": {
    "name": "Jos√© F. Romaniello",
    "email": "jfromaniello@gmail.com",
    "url": "http://joseoncode.com"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/auth0/socketio-jwt.git"
  },
  "scripts": {
    "test": "mocha"
  },
  "license": "MIT",
  "dependencies": {
    "jsonwebtoken": "^5.0.0",
    "xtend": "~2.1.2"
  },
  "devDependencies": {
    "body-parser": "~1.13.3",
    "express": "~4.10.6",
    "mocha": "~1.17.0",
    "passport-local": "~0.1.6",
    "request": "~2.19.0",
    "serve-static": "^1.7.1",
    "server-destroy": "~1.0.1",
    "should": "~1.2.2",
    "socket.io": "^1.0.4",
    "socket.io-client": "^1.0.4"
  },
  "readme": "[![Build Status](https://travis-ci.org/auth0/socketio-jwt.svg)](https://travis-ci.org/auth0/socketio-jwt)\n\nAuthenticate socket.io incoming connections with JWTs. This is useful if you are build a single page application and you are not using cookies as explained in this blog post: [Cookies vs Tokens. Getting auth right with Angular.JS](http://blog.auth0.com/2014/01/07/angularjs-authentication-with-cookies-vs-token/).\n\n## Installation\n\n```\nnpm install socketio-jwt\n```\n\n## Example usage\n\n```javascript\n// set authorization for socket.io\nio.sockets\n  .on('connection', socketioJwt.authorize({\n    secret: 'your secret or public key',\n    timeout: 15000 // 15 seconds to send the authentication message\n  })).on('authenticated', function(socket) {\n    //this socket is authenticated, we are good to handle more events from it.\n    console.log('hello! ' + socket.decoded_token.name);\n  });\n```\n\n**Note:** If you are using a base64-encoded secret (e.g. your Auth0 secret key), you need to convert it to a Buffer: `Buffer('your secret key', 'base64')`\n\n__Client side__:\n\n```javascript\nvar socket = io.connect('http://localhost:9000');\nsocket.on('connect', function (socket) {\n  socket\n    .on('authenticated', function () {\n      //do other things\n    })\n    .emit('authenticate', {token: jwt}); //send the jwt\n});\n```\n\n## One roundtrip\n\nThe previous approach uses a second roundtrip to send the jwt, there is a way you can authenticate on the handshake by sending the JWT as a query string, the caveat is that intermediary HTTP servers can log the url.\n\n```javascript\nvar io            = require(\"socket.io\")(server);\nvar socketioJwt   = require(\"socketio-jwt\");\n\n//// With socket.io < 1.0 ////\nio.set('authorization', socketioJwt.authorize({\n  secret: 'your secret or public key',\n  handshake: true\n}));\n//////////////////////////////\n\n//// With socket.io >= 1.0 ////\nio.use(socketioJwt.authorize({\n  secret: 'your secret or public key',\n  handshake: true\n}));\n///////////////////////////////\n\nio.on('connection', function (socket) {\n  // in socket.io < 1.0\n  console.log('hello!', socket.handshake.decoded_token.name);\n\n  // in socket.io 1.0\n  console.log('hello! ', socket.decoded_token.name);\n})\n```\n\nFor more validation options see [auth0/jsonwebtoken](https://github.com/auth0/node-jsonwebtoken).\n\n__Client side__:\n\nAppend the jwt token using query string:\n\n```javascript\nvar socket = io.connect('http://localhost:9000', {\n  'query': 'token=' + your_jwt\n});\n```\n\n## Handling token expiration\n\n__Server side__:\n\nWhen you sign the token with an expiration time:\n\n```javascript\nvar token = jwt.sign(user_profile, jwt_secret, {expiresInMinutes: 60});\n```\n\nYour client-side code should handle it as below.\n\n__Client side__:\n\n```javascript\nsocket.on(\"error\", function(error) {\n  if (error.type == \"UnauthorizedError\" || error.code == \"invalid_token\") {\n    // redirect user to login page perhaps?\n    console.log(\"User's token has expired\");\n  }\n});\n```\n## Getting the secret dynamically\nYou can pass a function instead of an string when configuring secret.\nThis function receives the request, the decoded token and a callback. This\nway, you are allowed to use a different secret based on the request and / or\nthe provided token.\n\n__Server side__:\n\n```javascript\nvar SECRETS = {\n  'user1': 'secret 1',\n  'user2': 'secret 2'\n}\n\nio.use(socketioJwt.authorize({\n  secret: function(request, decodedToken, callback) {\n    // SECRETS[decodedToken.userId] will be used a a secret or\n    // public key for connection user.\n\n    callback(null, SECRETS[decodedToken.userId]);\n  },\n  handshake: false\n}));\n\n```\n\n## Contribute\n\nYou are always welcome to open an issue or provide a pull-request!\n\nAlso check out the unit tests:\n```bash\nnpm test\n```\n\n## Issue Reporting\n\nIf you have found a bug or if you have a feature request, please report them at this repository issues section. Please do not report security vulnerabilities on the public GitHub issue tracker. The [Responsible Disclosure Program](https://auth0.com/whitehat) details the procedure for disclosing security issues.\n\n## Author\n\n[Auth0](auth0.com)\n\n## License\n\nThis project is licensed under the MIT license. See the [LICENSE](LICENSE) file for more info.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/auth0/socketio-jwt/issues"
  },
  "_id": "socketio-jwt@4.3.4",
  "dist": {
    "shasum": "91ba382984764277750b63de3fdb69543bcabe4b"
  },
  "_from": "socketio-jwt@4.3.4",
  "_resolved": "https://registry.npmjs.org/socketio-jwt/-/socketio-jwt-4.3.4.tgz"
}
